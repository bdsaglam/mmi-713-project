/**
  * Gathers k-th smallest distances for each row of the distance matrix in the top.
  *
  * @param distances   pointer for distances array
  * @param indices     pointer for indices array
  * @param n_rows      number of columns
  * @param n_cols      number of rows
  * @param k           number of smallest element to select
  */
__global__ void kSelectKernel(float *distances, long *indices, int n_rows, int n_cols, int k) {
  
  unsigned int yIndex = blockIdx.x * blockDim.x + threadIdx.x;
  if (yIndex >= n_rows) return;

  // Pointer shift, initialization, and max value
  float *p_dist = distances + yIndex * n_cols;
  long *p_ind = indices + yIndex * n_cols;

  float max_dist = p_dist[0];
  p_ind[0] = 0;

  int l, i;

  // Part 1 : sort k-th first elements
  float curr_dist;
  long  curr_col;
  for (l = 1; l < k; l++) {
    curr_col  = l;
    curr_dist = p_dist[curr_col];
    if (curr_dist < max_dist) {
      // new small element found
      // find insertion index
      i = l - 1;
      for (int a = 0; a < l - 1; a++) {
        if (p_dist[a] > curr_dist) {
          i = a;
          break;
        }
      }
      // shift all elements after insertion index to right
      for (int j = l; j > i; j--) {
        p_dist[j] = p_dist[j - 1];
        p_ind[j]  = p_ind[j - 1];
      }
      p_dist[i] = curr_dist;
      p_ind[i]  = l;
    } else {
      p_ind[l] = l;
    }
    max_dist = p_dist[curr_col];
  }

  // Part 2 : insert element in the k-th first lines
  long max_col = k - 1;
  for (l = k; l < n_cols; l++) {
    curr_dist = p_dist[l];
    if (curr_dist < max_dist) {
      i = k - 1;
      for (int a = 0; a < k - 1; a++) {
        if (p_dist[a] > curr_dist) {
          i = a;
          break;
        }
      }
      for (int j = k - 1; j > i; j--) {
        p_dist[j] = p_dist[j - 1];
        p_ind[j]  = p_ind[j - 1];
      }
      p_dist[i] = curr_dist;
      p_ind[i]  = l;
      max_dist  = p_dist[max_col];
    }
  }
}
